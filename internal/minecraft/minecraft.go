package minecraft

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// MCConfig represents a Minecraft server.properties configuration
type MCConfig struct {
	FilePath string
	Config   map[string]string
}

// NewMCConfig creates a new MCConfig instance from a file
func NewMCConfig(filepath string) (*MCConfig, error) {
	mc := &MCConfig{
		FilePath: filepath,
		Config:   make(map[string]string),
	}

	file, err := os.Open(filepath)
	if err != nil {
		return nil, fmt.Errorf("failed to open config file: %w", err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		
		// Skip comments and empty lines
		if strings.HasPrefix(line, "#") || line == "" {
			continue
		}

		// Split on first '=' only
		parts := strings.SplitN(line, "=", 2)
		if len(parts) == 2 {
			key := strings.TrimSpace(parts[0])
			value := strings.TrimSpace(parts[1])
			mc.Config[key] = value
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error reading config file: %w", err)
	}

	return mc, nil
}

// UpdateConfig updates a configuration property
func (mc *MCConfig) UpdateConfig(property, value string) {
	mc.Config[property] = value
}

// WriteConfig writes the configuration to a file
func (mc *MCConfig) WriteConfig(filepath string) error {
	file, err := os.Create(filepath)
	if err != nil {
		return fmt.Errorf("failed to create config file: %w", err)
	}
	defer file.Close()

	writer := bufio.NewWriter(file)
	defer writer.Flush()

	// Write a header comment
	fmt.Fprintln(writer, "#Minecraft server properties")
	fmt.Fprintln(writer, "#Generated by AUMC")
	fmt.Fprintln(writer)

	// Write configuration properties
	for key, value := range mc.Config {
		fmt.Fprintf(writer, "%s=%s\n", key, value)
	}

	return nil
}

// Get retrieves a configuration value
func (mc *MCConfig) Get(property string) (string, bool) {
	value, exists := mc.Config[property]
	return value, exists
}

// Set sets a configuration value
func (mc *MCConfig) Set(property, value string) {
	mc.Config[property] = value
}

// ServerManager handles Minecraft server operations
type ServerManager struct {
	MSMPath string
}

// NewServerManager creates a new ServerManager instance
func NewServerManager(msmPath string) *ServerManager {
	return &ServerManager{
		MSMPath: msmPath,
	}
}

// WorldInfo represents information about a Minecraft world
type WorldInfo struct {
	Name             string
	JarGroup         string
	MinecraftVersion string
	ServerProperties string
	OpUsernames      []string
}

// CreateWorld creates a new Minecraft world
func (sm *ServerManager) CreateWorld(info *WorldInfo) error {
	// TODO: Implement world creation using MSM
	fmt.Printf("Creating world: %s with jargroup: %s, version: %s\n", 
		info.Name, info.JarGroup, info.MinecraftVersion)
	return fmt.Errorf("world creation not yet implemented")
}

// DeleteWorld deletes a Minecraft world after creating a backup
func (sm *ServerManager) DeleteWorld(worldName string) error {
	// TODO: Implement world deletion with backup
	fmt.Printf("Deleting world: %s (with backup)\n", worldName)
	return fmt.Errorf("world deletion not yet implemented")
}

// RestoreWorld restores a world from backup
func (sm *ServerManager) RestoreWorld(worldName, backupPath string) error {
	// TODO: Implement world restoration
	fmt.Printf("Restoring world: %s from backup: %s\n", worldName, backupPath)
	return fmt.Errorf("world restoration not yet implemented")
}

// BuildJar builds a Spigot jar using BuildTools
func (sm *ServerManager) BuildJar(version, tempFolder, buildToolsJar, outputFolder string) error {
	// TODO: Implement jar building
	fmt.Printf("Building Spigot jar for version: %s\n", version)
	fmt.Printf("  Temp folder: %s\n", tempFolder)
	fmt.Printf("  BuildTools jar: %s\n", buildToolsJar)
	fmt.Printf("  Output folder: %s\n", outputFolder)
	return fmt.Errorf("jar building not yet implemented")
}

// DirectoryManager provides utilities for managing directories
type DirectoryManager struct {
	originalDir string
}

// NewDirectoryManager creates a new DirectoryManager
func NewDirectoryManager() *DirectoryManager {
	cwd, _ := os.Getwd()
	return &DirectoryManager{originalDir: cwd}
}

// EnterDir changes to a directory and returns a function to restore the original directory
func (dm *DirectoryManager) EnterDir(path string) (func(), error) {
	expandedPath := filepath.Clean(os.ExpandEnv(path))
	
	if err := os.Chdir(expandedPath); err != nil {
		return nil, fmt.Errorf("failed to change directory to %s: %w", expandedPath, err)
	}

	return func() {
		os.Chdir(dm.originalDir)
	}, nil
}

// Custom errors for Minecraft operations
type ServerCreationError struct {
	WorldName string
	Err       error
}

func (e *ServerCreationError) Error() string {
	return fmt.Sprintf("failed to create server %s: %v", e.WorldName, e.Err)
}

type RestoreError struct {
	WorldName string
	Err       error
}

func (e *RestoreError) Error() string {
	return fmt.Sprintf("failed to restore world %s: %v", e.WorldName, e.Err)
}